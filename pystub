#!/usr/bin/env python3
#DNS stub server with support for DNS over TLS.
#
#RFC 1035: DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION
#RFC 7766: DNS Transport over TCP - Implementation Requirements
#RFC 7858: Specification for DNS over Transport Layer Security (TLS)
#
#SSHFP RFCs
#RFC 4255: Using DNS to Securely Publish Secure Shell (SSH) Key Fingerprints
#RFC 6594: Use of the SHA-256 Algorithm with RSA, Digital Signature Algorithm (DSA), and Elliptic Curve DSA (ECDSA) in SSHFP Resource Records
#RFC 7479: Using Ed25519 in SSHFP Resource Records
#Status: Work in Progress

import socket
import socketserver
import threading
import random
import sys
import ssl
import yaml
import re
import urllib.request
import argparse
import os

qtypes = {'A'    :  1,
          'NS'   :  2,
          'CNAME':  5,
          'SOA'  :  6,
          'PTR'  : 12,
          'MX'   : 15,
          'TXT'  : 16,
          'AAAA' : 28,
          'SRV'  : 33,
          'SSHFP': 44}

qclasses = {'IN': 1}

rcodes = {0: "No Error",
          1: "Format Error",
          2: "Server Failure",
          3: "Non-Existent Domain",
          4: "Not Implemented",
          5: "Query Refused"}

sshfp_algs = {'RSA'    : 1,
              'DSS'    : 2,
              'ECDSA'  : 3,
              'Ed25519': 4}

sshfp_types = {'SHA-1'  : 1,
               'SHA-256': 2}

class upstream:
    upstreams = []
    enabled   = []

    def __init__(self, addr, tls_name, port, tcp):
        #TODO: verify valid input
        self.address  = addr
        self.tls_name = tls_name
        self.port     = port
        self.tcp      = 1 if len(tls_name) > 0 else tcp
        self.tls      = 1 if len(tls_name) > 0 else 0
        upstream.upstreams.append(self)
        upstream.enabled.append(self)

    @staticmethod
    def get_server():
        if random.randrange(1000) == 999 or len(upstream.enabled) == 0:
            upstream.enabled = upstream.upstreams.copy()
        return random.choice(upstream.enabled)

    def connect(self):
        timeout = 2 #Seconds
        if self.tls:
            cnxt  = ssl.create_default_context()
            try:
                sock  = socket.create_connection((self.address, self.port), timeout)
            except Exception:
                print("Unable to connect to "+self.tls_name)
                if self in upstream.enabled: upstream.enabled.remove(self)
                return None
            upstr = cnxt.wrap_socket(sock, server_hostname=self.tls_name)
        else:
            sock_type = socket.SOCK_STREAM if self.tcp else socket.SOCK_DGRAM
            upstr = socket.socket(socket.AF_INET, sock_type)
            upstr.settimeout(timeout)
            try:
                upstr.connect((self.address, self.port))
            except Exception:
                print("Unable to connect to "+self.address)
                if self in upstream.enabled: upstream.enabled.remove(self)
                return None
        return upstr

    def close(self, conn):
        conn.shutdown(socket.SHUT_WR)
        conn.close()

    def sendall(self, conn, packet):
        if self.tcp:
            packet_len = len(packet).to_bytes(2, byteorder='big')
            packet = packet_len + packet
        return conn.sendall(packet)

    def recvall(self, conn):
        if self.tcp:
            conn.settimeout(6)
            try:
                packet = conn.recv(4096)
            except Exception:
                return ""
            enc_len = int.from_bytes(packet[:2], 'big')
            pkt_len = len(packet) - 2
            packet = packet[2:]
            while pkt_len < enc_len:
                try:
                    packet += conn.recv(enc_len - pkt_len)
                except Exception:
                    return ""
                pkt_len += len(packet)
            return packet
        else:
            try:
                return conn.recv(512)
            except Exception:
                return ""

def gen_packet(header, query):
    return header + query

def gen_header(trans_id, flags, QDCount, ANCount, NSCount, ARCount):
    trans_id = trans_id.to_bytes(2, 'big')
    QDCount  = QDCount.to_bytes(2, 'big')
    ANCount  = ANCount.to_bytes(2, 'big')
    NSCount  = NSCount.to_bytes(2, 'big')
    ARCount  = ARCount.to_bytes(2, 'big')
    return trans_id + flags + QDCount + ANCount + NSCount + ARCount

#QR     : Query: 0, Response: 1
#OpCode : Standard Query: 0000, Inverse Query: 0100
#AA     : Authoritative Answer
#TC     : Is Message truncated
#RD     : Do query recursively
#RA     : Is recursive support available in the NS
#Z      : Reserved
#RCode  : Response Code
def gen_flags(QR, OpCode=0, AA=0, TC=0, RD=0, RA=0, Z=0, RCode=0):
    flags = QR*(2**15) | OpCode*(2**11) | AA*(2**10)| TC*(2**9) | RD*(2**8) | RA*(2**7) | Z*(2**4) | RCode
    return flags.to_bytes(2, byteorder='big')

def parse_flags(flags):
    QR      = (flags >> 15) & 2**1-1
    OpCode  = (flags >> 11) & 2**4-1
    AA      = (flags >> 10) & 2**1-1
    TC      = (flags >>  9) & 2**1-1
    RD      = (flags >>  8) & 2**1-1
    RA      = (flags >>  7) & 2**1-1
    Z       = (flags >>  6) & 2**1-1
    AD      = (flags >>  5) & 2**1-1 #RFC 4035
    CD      = (flags >>  4) & 2**1-1 #RFC 4035
    RCode   = (flags >>  0) & 2**4-1
    return {"QR":QR, "OpCode":OpCode, "AA":AA, "TC":TC, "RD":RD, "RA":RA, "Z":Z, "AD":AD, "CD":CD, "RCode":RCode}

#Reverse map function for 1:1 dictionaries
def reverse_get(dictionary, value):
    rev = {v: k for k, v in dictionary.items()}
    return rev.get(value)

def gen_name(qname):
    if not isinstance(qname, str):
        return None
    if len(qname) > 253:
        return None
    dns_name = str.encode('')
    parts = qname.split('.')
    for part in parts:
        if len(part) > 63:
            return None
        dns_name += str.encode(chr(len(part))+part)
    dns_name += str.encode(chr(0))
    return dns_name

def parse_name(start, packet, pointers=None):
    if pointers is None:
        pointers = []
    if start in pointers:
        print("Circular name reference detected. Aborting name parsing...")
        return None
    pointers.append(start)
    name_str = ''
    i = start
    while i < len(packet): 
        if packet[i] > 0:
            if(packet[i] >= 0xc0):
                if debug: print("Compressed name received. Following reference")
                offset = int.from_bytes(packet[i:i+2], 'big') & 2**14-1
                parsed = parse_name(offset, packet, pointers)
                if parsed is None:
                    return parsed
                name_str += parsed
                return name_str
            count = packet[i]
            if len(packet) < i+count+1:
                print("Malformed name")
                return None
            name_bytes = packet[i+1:i+count+1]
            if any(byte > 127 for byte in name_bytes):
                print("Non ascii character received. This is not supported yet")
                return None
            name_str += name_bytes.decode("ascii")
            name_str += '.'
            i+=count+1
        else:
            name_str = name_str[:-1]
            return name_str
    return None

def skip_name(start, data):
    i = start
    while i < len(data):
        if data[i] > 0:
            if data[i] >= 0xc0:
                return i + 2
            i += 1
        else:
            return i + 1
    return -1

def gen_question(qname, qtype, qclass):
    query = gen_name(qname)
    if query is None:
        print("Invalid query name given")
        return None
    if qtype not in qtypes.keys():
        print("Support not implemented for record type: " + str(qtype))
        return None
    if qclass not in qclasses.keys():
        print("Support not implemented for query class type: " + str(qclass))
        return None
    query += qtypes[qtype].to_bytes(2, byteorder='big')
    query += qclasses[qclass].to_bytes(2, byteorder='big')
    return query

def parse_question(start, data):
    qname = parse_name(start, data)
    if qname is None:
        return {'ERROR':'Error parsing qname'}
    pos = skip_name(start, data)
    if pos < 0 or len(data) < pos+4:
        return {'ERROR':'Malformed packet'}
    qtype_int = int.from_bytes(data[pos:pos+2], 'big')
    qtype = reverse_get(qtypes, qtype_int)
    if qtype is None:
        return {'ERROR':'Unsupported qtype: ' + str(qtype_int)}
    qclass_int = int.from_bytes(data[pos+2:pos+4], 'big')
    qclass = reverse_get(qclasses, qclass_int)
    if qclass is None: 
        return {'ERROR':'Unsupported qclass: ' + str(qclass_int)}
    return {'QNAME':qname, "QTYPE":qtype, 'QCLASS':qclass}

def gen_trans_id():
    return random.randrange(2**16-1)

def parse_rdata(qtype, start, data):
    rdata = {}
    if qtype == qtypes['A']:
        if debug: print("Parsing A record")
        rdata['ADDRESS'] = str(data[start])+'.'+str(data[start+1])+'.'+str(data[start+2])+'.'+str(data[start+3])
    elif qtype == qtypes['NS']:
        if debug: print("Parsing NS record")
        rdata['NSDNAME'] = parse_name(start, data)
    elif qtype == qtypes['CNAME']:
        if debug: print("Parsing CNAME record")
        rdata['CNAME'] =  parse_name(start, data)
    elif qtype == qtypes['SOA']:
        if debug: print("Parsing SOA record")
        rdata['MNAME']  = parse_name(start, data)
        start = skip_name(start, data)
        rdata['RNAME']  = parse_name(start, data)
        start = skip_name(start, data)
        rdata['SERIAL']  = int.from_bytes(data[start:start+4], 'big')
        rdata['REFRESH'] = int.from_bytes(data[start+4:start+8], 'big')
        rdata['RETRY']   = int.from_bytes(data[start+8:start+12], 'big')
        rdata['EXPIRE']  = int.from_bytes(data[start+12:start+16], 'big')
        rdata['MINIMUM'] = int.from_bytes(data[start+16:start+20], 'big')
    elif qtype == qtypes['PTR']:
        if debug: print("Parsing PTR record")
        rdata['PTRDNAME'] = parse_name(start, data)
    elif qtype == qtypes['MX']:
        if debug: print("Parsing MX record")
        rdata['PREFERENCE'] = int.from_bytes(data[start:start+2], 'big')
        rdata['EXCHANGE']   = parse_name(start+2, data)
    elif qtype == qtypes['TXT']:
        if debug: print("Parsing TXT record")
        length = int.from_bytes(data[start-2:start], 'big')
        curr_size = 0
        rdata['TXT-DATA'] = []
        while curr_size < length and data[start+curr_size]:
            size = data[start+curr_size]
            rdata['TXT-DATA'].append(data[start+curr_size+1:start+curr_size+1+size].decode("ascii"))
            curr_size += (1+size)
    elif qtype == qtypes['AAAA']:
        if debug: print("Parsing AAAA record")
        AAAA = ''
        for i in range(8): AAAA += (str(data[start+2*i:start+2*i+2].hex())+':')
        rdata['ADDRESS'] = AAAA[:-1]
    elif qtype == qtypes['SRV']: #RFC 2782
        if debug: print("Parsing SRV record")
        rdata['PRIORITY'] = int.from_bytes(data[start:start+2], 'big')
        rdata['WEIGHT']   = int.from_bytes(data[start+2:start+4], 'big')
        rdata['PORT']     = int.from_bytes(data[start+4:start+6], 'big')
        rdata['TARGET']   = parse_name(start+6, data)
    elif qtype == qtypes['SSHFP']:
        if debug: print("Parsing SSHFP record")
        fing_alg  = int.from_bytes(data[start:start+1], 'big')
        fing_type = int.from_bytes(data[start+1:start+2], 'big')
        fing_len  = 0
        if fing_type == 1: fing_len = 20
        elif fing_type == 2: fing_len = 32
        fing_alg  = reverse_get(sshfp_algs,  fing_alg)
        fing_type = reverse_get(sshfp_types, fing_type)
        if fing_alg is None or fing_type is None:
            print("Unknown SSHFP algorithm/type encountered")
            return None
        rdata['ALGORITHM']   = fing_alg
        rdata['FP_TYPE']     = fing_type
        rdata['FINGERPRINT'] = str(data[start+2:start+2+fing_len].hex())
    else:
        print("Parsing not implemented for record type: " + str(qtype))
        rdata = None
    return rdata

def gen_rdata(data):
    rdata = b''
    qtype = data['QTYPE'];
    if qtype == 'A':
        if debug: print("Building A record")
        size   = 4
        add    = data['ADDRESS'].split('.')
        rdata += size.to_bytes(2, byteorder='big')
        for i in range(4):
          rdata += int(add[i]).to_bytes(1, 'big')
    elif qtype == 'NS':
        if debug: print("Building NS record")
        nsdname = gen_name(data['NSDNAME'])
        rdata   += len(nsdname).to_bytes(2, byteorder='big')
        rdata   += nsdname
    elif qtype == 'CNAME':
        if debug: print("Building CNAME record")
        cname  = gen_name(data['CNAME'])
        rdata += len(cname).to_bytes(2, byteorder='big')
        rdata += cname
    elif qtype == 'SOA':
        if debug: print("Building SOA record")
        mname   = gen_name(data['MNAME'])
        rname   = gen_name(data['RNAME'])
        size    = len(mname) + len(rname) + 4*5
        serial  = data['SERIAL'].to_bytes(4, byteorder='big')
        refresh = data['REFRESH'].to_bytes(4, byteorder='big')
        retry   = data['RETRY'].to_bytes(4, byteorder='big')
        expire  = data['EXPIRE'].to_bytes(4, byteorder='big')
        minimum = data['MINIMUM'].to_bytes(4, byteorder='big')
        rdata  += size.to_bytes(2, byteorder='big')
        rdata  += mname + rname + serial + refresh + retry + expire + minimum
    elif qtype == 'PTR':
        if debug: print("Building PTR record")
        ptrdname = gen_name(data['PTRDNAME'])
        rdata += len(ptrdname).to_bytes(2, byteorder='big')
        rdata += ptrdname
    elif qtype == 'MX':
        if debug: print("Building MX record")
        pref = data['PREFERENCE'].to_bytes(2, byteorder='big')
        exch = gen_name(data['EXCHANGE'])
        size = len(exch) + 2
        rdata  += size.to_bytes(2, byteorder='big')
        rdata  += pref + exch
    elif qtype == 'TXT':
        if debug: print("Parsing TXT record")
        txtdata = data['TXT-DATA']
        tot_len = 0
        tmp = str.encode('')
        for entry in txtdata:
            length  = len(entry).to_bytes(1, byteorder='big')
            val     = str.encode(entry)
            tmp     += length + val
            tot_len += 1 + len(val)
        rdata += tot_len.to_bytes(2, byteorder='big')
        rdata += tmp
    elif qtype == 'AAAA':
        if debug: print("Building AAAA record")
        size   = 16
        rdata += size.to_bytes(2, byteorder='big')
        aaaa   = data['ADDRESS']
        for group in aaaa.split(':'): rdata += bytes.fromhex(group)
    elif qtype == 'SRV':
        if debug: print("Building SRV record")
        priority = data['PRIORITY'].to_bytes(2, byteorder='big')
        weight   = data['WEIGHT'].to_bytes(2, byteorder='big')
        port     = data['PORT'].to_bytes(2, byteorder='big')
        target   = gen_name(data['TARGET'])
        size     = 6 + len(target)
        rdata   += size.to_bytes(2, byteorder='big')
        rdata   += priority + weight + port + target
    elif qtype == 'SSHFP':
        if debug: print("Building SSHFP record")
        fing_alg  = sshfp_algs.get(data['ALGORITHM'])
        fing_type = sshfp_types.get(data['FP_TYPE'])
        if fing_alg is None or fing_type is None:
            print("Unknown SSHFP algorithm/type encountered")
            return rdata
        fing_alg  = fing_alg.to_bytes(1, byteorder='big')
        fing_type = fing_type.to_bytes(1, byteorder='big')
        fing      = bytes.fromhex(data['FINGERPRINT'])
        sshfp     = fing_alg + fing_type + fing
        rdata    += len(sshfp).to_bytes(2, byteorder='big')
        rdata    += sshfp
    else:
        print("Writing not implmented for record type: " + str(qtype))
        print(data)
    return rdata

def gen_RRs(data):
    response = ''
    if data['QDCount']:
      qname  = data['Question'][0]['QNAME']
      qtype  = data['Question'][0]['QTYPE']
      qclass = data['Question'][0]['QCLASS']
      response = gen_name(qname)
      if response is None:
          return None
      response += qtypes[qtype].to_bytes(2, byteorder='big')
      response += qclasses[qclass].to_bytes(2, byteorder='big')
    for section in ['Answer', 'Authority', 'Additional']:
        count = 0
        if section == 'Answer' and data['ANCount']:
            count = data['ANCount']
        elif section == 'Authority' and data['NSCount']:
            count = data['NSCount']
        elif section == 'Additional' and data['ARCount']:
            count = data['ARCount']
        for i in range(count):
            qname  = data[section][i]['QNAME']
            qtype  = data[section][i]['QTYPE']
            qclass = data[section][i]['QCLASS']
            ttl    = data[section][i]['TTL']

            tmp_res  = gen_name(qname)
            if response is None:
                return None
            tmp_res += qtypes[qtype].to_bytes(2, byteorder='big')
            tmp_res += qclasses[qclass].to_bytes(2, byteorder='big')
            tmp_res += ttl.to_bytes(4, byteorder='big')
            rdata    = gen_rdata(data[section][i])
            if len(rdata) > 0 : #Type implemented
                tmp_res  += rdata
                response += tmp_res
    return response

def parse_packet(packet):
    ret = {}
    pkt_len = len(packet) #Length of the packet received
    
    #parse header
    if pkt_len < 12:
        print("Packet length too short.")
        ret['ERROR'] = "Packet length too short"
        return ret
    header = packet[:12]
    trans_id = int.from_bytes(header[:2], 'big')
    flags    = int.from_bytes(header[2:4], 'big')
    QDCount  = int.from_bytes(header[4:6], 'big')   #Number of questions
    ANCount  = int.from_bytes(header[6:8], 'big')   #Number of answers
    NSCount  = int.from_bytes(header[8:10], 'big')  #Number of NS RRs
    ARCount  = int.from_bytes(header[10:12], 'big') #Number of add RRS

    ret['TXID'] = trans_id

    flags = parse_flags(flags)
    ret['FLAG'] = flags

    RCode = flags["RCode"]
    if RCode not in rcodes:
        print("RCode not implemented.")
        ret['ERROR'] = "RCode not implemented"
        return ret

    ret['RCODE']   = rcodes[RCode]
    ret['QDCount'] = QDCount
    ret['ANCount'] = ANCount
    ret['NSCount'] = NSCount
    ret['ARCount'] = ARCount

    pos = 12
    ret['Question'] = []
    if(QDCount):
        if debug: print("Packet query section. Parsing...")
        if QDCount > 1:
            print("QDCount > 1 not supported. Disregarding additional queries")
            ret['QDCount'] = 1
        qdata = parse_question(pos, packet)
        if 'ERROR' in qdata:
            ret['ERROR'] = qdata['ERROR']
            #TODO: Should we set QDCount to 0?
            return ret
        pos = skip_name(pos, packet)+4
        #Probably not going to support multiple queries, but storing in list anyway
        ret['Question'] = []
        ret['Question'].append(qdata)
    for section in ('Answer', 'Authority', "Additional"):
        if section == 'Answer':
            count = ANCount
        elif section == "Authority":
            count = NSCount
        elif section == "Additional":
            count = ARCount
        if count and debug: print("Response contains " + section + " section. Parsing...")
        ret[section] = []
        if pkt_len < pos + count*10: #sanity check so we don't loop a crazy number of times on a malformed packet
            ret['ERROR'] = "Malformed packet" #TODO: revisit this when we wire up truncation
            return ret
        for i in range(count):
            qname = parse_name(pos, packet)
            pos   = skip_name(pos, packet)
            if pkt_len < pos+10:
                ret['ERROR'] = "Malformed packet"
                return ret
            qtype    = int.from_bytes(packet[pos:pos+2], 'big')
            qclass   = int.from_bytes(packet[pos+2:pos+4], 'big')
            ttl      = int.from_bytes(packet[pos+4:pos+8], 'big')
            RDlength = int.from_bytes(packet[pos+8:pos+10], 'big')
            pos += 10
            if pkt_len < pos + RDlength:
                ret['ERROR'] = "Malformed packet"
                return ret
            RData = parse_rdata(qtype, pos, packet)
            if RData is None: #unable to parse rdata record. Decrement appropriate count
                if   section == 'Answer':     ret['ANCount'] -= 1
                elif section == 'Authority':  ret['NSCount'] -= 1
                elif section == 'Additional': ret['ARCount'] -= 1
            else:
                RData['QNAME']  = qname
                RData['QTYPE']  = reverse_get(qtypes, qtype)
                RData['QCLASS'] = reverse_get(qclasses, qclass)
                RData['TTL']    = ttl
                ret[section].append(RData)
            pos += RDlength
    return ret

######DEFAULT SETTINGS######
deflt_cnfg_file = '/etc/pystub.yml'
debug = 0
upstrm_cnfgs = [
                {
                 "address":'8.8.8.8',
                 "tls_name":"dns.google",
                 "port":853,
                 "tcp":1
                }
               ]
blacklist = []
#############################
def main():
    global debug
    global upstrm_cnfgs
    global blacklist

    MIN_PYTHON = (3, 5)
    if sys.version_info < MIN_PYTHON:
      sys.exit("Python %s.%s or later is required.\n" % MIN_PYTHON)

    parser = argparse.ArgumentParser(description='Pystub DNS stub resolver')
    parser.add_argument('-C', dest='config_file', help='Configuration file location')
    parser.add_argument('-v', dest='verbose', action='store_true', help='Verbose output')
    args = parser.parse_args()
    config_file = args.config_file
    debug       = args.verbose

    #Parse config
    if config_file is None:
        config_file = deflt_cnfg_file if os.path.isfile(deflt_cnfg_file) else None
    config = []
    if config_file:
        with open(config_file, "r") as c:
            try:
                config = yaml.safe_load(c)
            except yaml.YAMLError as exc:
                print(exc)
                sys.exit(1)
    if "upstreams" in config and len(config["upstreams"]) > 0:
        upstrm_cnfgs = config["upstreams"]
    listen_add = ""
    if "listen" in config and len(config["listen"]) > 0:
        listen_add = config["listen"][0] #TODO: support for multiple listen addresses
    if "blacklist" in config and len(config["blacklist"]) > 0:
        domain_regex = "^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$"
        if "url" in config["blacklist"]:
            for url in config["blacklist"]["url"]:
                try:
                    page = urllib.request.urlopen(url)
                except Exception:
                    print("Unable to parse blocklist from " + url)
                    continue
                for line in page:
                    domain = line.decode('utf-8').rstrip()
                    if re.fullmatch(domain_regex, domain):
                        blacklist.append(domain)
        if "domain" in config["blacklist"]:
            for domain in config["blacklist"]["domain"]:
                if re.fullmatch(domain_regex, domain):
                    blacklist.append(domain)
        print("Imported " + str(len(blacklist)) + " blacklist domains")

    #Parse upstreams
    for cnfg in upstrm_cnfgs:
        new_upstr = upstream(cnfg["address"], cnfg["tls_name"], cnfg["port"], cnfg["tcp"])
        new_upstr.connect() #TODO: implement better verification

    tcp_server = ThreadedTCPServer((listen_add, 53), ThreadedTCPRequestHandler)
    tcp_server_thread = threading.Thread(target=tcp_server.serve_forever)
    tcp_server_thread.start()
    udp_server = ThreadedUDPServer((listen_add, 53), ThreadedUDPRequestHandler)
    udp_server_thread = threading.Thread(target=udp_server.serve_forever)
    udp_server_thread.start()
    print("Server listening on " + listen_add + " port 53\n")

class ThreadedTCPRequestHandler(socketserver.BaseRequestHandler):
    def handle(self):
        self.request.settimeout(6)
        try:
            packet = self.request.recv(4096)
        except Exception:
            return
        enc_len = int.from_bytes(packet[:2], 'big')
        pkt_len = len(packet) - 2
        packet = packet[2:]
        while pkt_len < enc_len:
            try:
                packet += self.request.recv(enc_len - pkt_len)
            except Exception:
                return
            pkt_len += len(packet)

        packet = process_query(packet)
        if packet is None:
            return #No response to send back to client
        packet_len = len(packet).to_bytes(2, byteorder='big')
        packet = packet_len + packet
        self.request.sendall(packet)

class ThreadedUDPRequestHandler(socketserver.BaseRequestHandler):
    def handle(self):
        request = self.request[0]
        packet = process_query(request)
        if packet is None:
            return #No response to send back to client
        self.request[1].sendto(packet, self.client_address)

class ThreadedTCPServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass

class ThreadedUDPServer(socketserver.ThreadingMixIn, socketserver.UDPServer): pass

def process_query(request):
    if debug: print("Received client query")
    parsed = parse_packet(request)
    if 'ERROR' in parsed:
        print('ERROR: '+parsed['ERROR'])
        if 'TXID' not in parsed:
            return None #Drop packet since we can't even reply
        cltxid = parsed['TXID']
        RD = 0
        if 'RD' in parsed['FLAG']:
            RD = parsed['FLAG']['RD']
        if parsed['ERROR'] == "Unsupported qtype":
            flags  = gen_flags(1, RD=RD, RA=1, RCode=4)
        elif parsed['ERROR'] == "Unsupported qclass":
            flags  = gen_flags(1, RD=RD, RA=1, RCode=4)
        elif parsed['ERROR'] == "Malformed packet":
            flags  = gen_flags(1, RD=RD, RA=1, RCode=1)
        elif parsed['ERROR'] == "Error parsing qname":
            flags  = gen_flags(1, RD=RD, RA=1, RCode=1)
        elif parsed['ERROR'] == "RCode not implemented":
            flags  = gen_flags(1, RD=RD, RA=1, RCode=4)
        else: #Send back server failure if we don't have a better code
            flags  = gen_flags(1, RD=RD, RA=1, RCode=2)
        return gen_header(cltxid, flags, 0, 0, 0, 0)
    cltxid = parsed['TXID']
    RD     = parsed['FLAG']['RD']
    if len(parsed['Question']) == 0:
        print("Empty query")
        flags  = gen_flags(1, RD=RD, RA=1, RCode=1)
        return gen_header(cltxid, flags, 0, 0, 0, 0)
    qname  = parsed['Question'][0]['QNAME']
    qtype  = parsed['Question'][0]['QTYPE']
    qclass = parsed['Question'][0]['QCLASS']
    if any(domain in qname for domain in blacklist) and qtype in ['A', 'AAAA']:
        print("Blocked: " + qname)
        flags  = gen_flags(1, RD=RD, RA=1)
        header = gen_header(cltxid, flags, 1, 1, 0, 0)
        parsed['ANCount'] = 1
        loopback = '127.0.0.1' if qtype == 'A' else '0000:0000:0000:0000:0000:0000:0000:0001'
        parsed['Answer'] = [{'ADDRESS': loopback, 'QNAME': qname, 'QTYPE': qtype, 'QCLASS': qclass, 'TTL': 3600}]
        response = gen_RRs(parsed)
        packet = gen_packet(header, response)
        if debug: print("Blocked domain\n\n")
        return packet
    if debug: print("Client query parsed\n")

    #Build and send query upstream
    if debug: print("Generating upstream query")
    flags  = gen_flags(0, RD=RD)
    header = gen_header(gen_trans_id(), flags, 1, 0, 0, 0)
    query  = gen_question(qname, qtype, qclass)
    if query is None:
        print("Error generating query.")
        flags  = gen_flags(1, RD=RD, RCode=2)
        return gen_header(cltxid, flags, 0, 0, 0, 0)
    packet = gen_packet(header, query)
    #TODO: Consider making this block a static fuction of upstream
    conn = None
    attempts = 0
    while conn is None and attempts < 10: #TODO: parallel?
        up = upstream.get_server()
        conn = up.connect()
        attempts += 1
    if conn is None:
        print("Error connecting upstream.")
        flags  = gen_flags(1, RD=RD, RA=1, RCode=2)
        return gen_header(cltxid, flags, 0, 0, 0, 0)
    up.sendall(conn, packet)
    if debug: print("Sent upstream query\n")

    #Receive and parse upstream response
    packet = up.recvall(conn)
    up.close(conn)
    if debug: print("Received upstream response")
    parsed = parse_packet(packet)
    if 'ERROR' in parsed:
        print('ERROR: '+parsed['ERROR'])
        flags  = gen_flags(1, RD=RD, RA=1, RCode=1)
        return gen_header(cltxid, flags, 0, 0, 0, 0)
    ANCount = parsed['ANCount']
    NSCount = parsed['NSCount']
    ARCount = parsed['ARCount']
    RCode   = parsed['RCODE']
    if debug: print("Upstream response parsed\n")

    #Build and send client response
    if debug: print("Generating client response")
    RCode    = reverse_get(rcodes, RCode)
    flags    = gen_flags(1, RD=RD, RA=1, RCode=RCode)
    header   = gen_header(cltxid, flags, 1, ANCount, NSCount, ARCount)
    response = gen_RRs(parsed)
    if response is None:
        print("Error generating client response.")
        flags  = gen_flags(1, RD=RD, RA=1, RCode=2)
        return gen_header(cltxid, flags, 0, 0, 0, 0)
    packet = gen_packet(header, response)
    if debug: print("Sent client response\n\n")
    return packet

if __name__ == "__main__":
    main()
